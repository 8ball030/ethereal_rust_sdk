/*
 * Ethereal Exchange API
 *
 * Ethereal HTTP API for real-time trading, order management, and market data access.
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct TransferDto {
    /// Id representing the transfer
    #[serde(rename = "id")]
    pub id: uuid::Uuid,
    /// Block number the transfer was initiated on
    #[serde(rename = "initiatedBlockNumber", skip_serializing_if = "Option::is_none")]
    pub initiated_block_number: Option<String>,
    /// Block number the transfer was completed on
    #[serde(rename = "finalizedBlockNumber", skip_serializing_if = "Option::is_none")]
    pub finalized_block_number: Option<String>,
    /// Current status of the transfer
    #[serde(rename = "status")]
    pub status: Status,
    /// Id representing the registered subaccount
    #[serde(rename = "subaccountId")]
    pub subaccount_id: uuid::Uuid,
    /// The unique exchange defined token name driven by addToken onchain
    #[serde(rename = "tokenName")]
    pub token_name: String,
    /// Address of token transferred (non-checksummed)
    #[serde(rename = "tokenAddress")]
    pub token_address: String,
    /// Type of transfer (WITHDRAW or DEPOSIT)
    #[serde(rename = "type")]
    pub r#type: Type,
    /// Amount of tokens transferred in native units expressed as a decimal (precision: 9)
    #[serde(rename = "amount")]
    pub amount: String,
    /// LayerZero destination address (leading 0x bytes32 encoded) for the transfer (if withdraw)
    #[serde(rename = "lzDestinationAddress", skip_serializing_if = "Option::is_none")]
    pub lz_destination_address: Option<String>,
    /// LayerZero destination endpoint ID for the transfer (if withdraw)
    #[serde(rename = "lzDestinationEid", skip_serializing_if = "Option::is_none")]
    pub lz_destination_eid: Option<f64>,
    /// Fee paid for the transfer in native units expressed as a decimal (precision: 9)
    #[serde(rename = "fee")]
    pub fee: String,
    /// Transfer creation timestamp (ms since Unix Epoch)
    #[serde(rename = "createdAt")]
    pub created_at: f64,
    /// Transaction hash for the initiation of the transfer
    #[serde(rename = "initiatedTransactionHash", skip_serializing_if = "Option::is_none")]
    pub initiated_transaction_hash: Option<String>,
    /// Transaction hash for the finalization of the transfer
    #[serde(rename = "finalizedTransactionHash", skip_serializing_if = "Option::is_none")]
    pub finalized_transaction_hash: Option<String>,
}

impl TransferDto {
    pub fn new(id: uuid::Uuid, status: Status, subaccount_id: uuid::Uuid, token_name: String, token_address: String, r#type: Type, amount: String, fee: String, created_at: f64) -> TransferDto {
        TransferDto {
            id,
            initiated_block_number: None,
            finalized_block_number: None,
            status,
            subaccount_id,
            token_name,
            token_address,
            r#type,
            amount,
            lz_destination_address: None,
            lz_destination_eid: None,
            fee,
            created_at,
            initiated_transaction_hash: None,
            finalized_transaction_hash: None,
        }
    }
}
/// Current status of the transfer
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Status {
    #[serde(rename = "SUBMITTED")]
    Submitted,
    #[serde(rename = "PENDING")]
    Pending,
    #[serde(rename = "COMPLETED")]
    Completed,
    #[serde(rename = "REJECTED")]
    Rejected,
}

impl Default for Status {
    fn default() -> Status {
        Self::Submitted
    }
}
/// Type of transfer (WITHDRAW or DEPOSIT)
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Type {
    #[serde(rename = "DEPOSIT")]
    Deposit,
    #[serde(rename = "WITHDRAW")]
    Withdraw,
}

impl Default for Type {
    fn default() -> Type {
        Self::Deposit
    }
}

